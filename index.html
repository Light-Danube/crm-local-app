<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Upload Video</title>
    <style>
      h1 {
        color: lightgray;
      }
      body {
        margin: 40px auto;
        max-width: 650px;
        background-color: #444;
      }
    </style>
  </head>
  <body>
    <h1>Upload Video</h1>
    <!-- Form to upload local videos -->
    <input type="file" name="video" id="videoFile" accept="video/*" />
    <button id="uploadButton">Upload</button>
    <!-- Form to stream YouTube videos -->
    <form id="youtubeForm">
      <input type="text" id="youtubeUrlInput" placeholder="Enter YouTube URL" />
      <button type="submit">Stream YouTube Video</button>
    </form>

    <!-- Video player -->
    <video id="videoPlayer" width="650" controls muted>
      <source type="video/mp4" />
    </video>

    <!-- Volume control -->
    <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="1" />

    <!-- Stop button -->
    <button id="stopButton">STOP</button>

    <!-- Endlessly Loop Video button-->
    <button id="toggleLoopButton">Toggle Loop</button>

    <!-- VIDEO EFFECTS BUTTONS:-->
    <label for="optimizeButton">Optimize Video</label>
    <input type="checkbox" id="optimizeButton">

    
    <label for="enhanceDetailsCheckbox">Enhance Details</label>
    <input type="checkbox" id="enhanceDetailsCheckbox">

    <label for="optimizeColorButton">Optimize Color</label>
    <input type="checkbox" id="optimizeColorButton">

    <label for="optimizeBackground">Optimize Background</label>
    <input type="checkbox" id="optimizeBackground">
  </body>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io("/playerControls");

    const videoFileInput = document.getElementById("videoFile");
    const videoPlayer = document.getElementById("videoPlayer");
    const volumeControl = document.getElementById("volumeControl");
    const uploadButton = document.getElementById("uploadButton");
    const youtubeForm = document.getElementById("youtubeForm");
    const youtubeUrlInput = document.getElementById("youtubeUrlInput");
    const stopButton = document.getElementById("stopButton");

    //Video Additional Effects:
    const toggleInversionCheckbox = document.getElementById("optimizeButton");
    const enhanceDetailsCheckbox = document.getElementById("enhanceDetailsCheckbox");
    const optimizeColorButton = document.getElementById("optimizeColorButton");
    const optimizeBackgroundCheckbox = document.getElementById("optimizeBackground");


    socket.on("file uploaded", () => console.log("file uploaded"));

    let loopEnabled = false;
    let optimizeColorChecked = false;
    let enhanceDetailsChecked = false;
    let backgroundOptimizeChecked = false;

    // Function to toggle loop feature
    toggleLoopButton.addEventListener('click', () => {
      loopEnabled = !loopEnabled;
      videoPlayer.loop = loopEnabled;
    });


    // Handle YouTube video streaming form submission
    youtubeForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      const youtubeUrl = youtubeUrlInput.value;

      try {
        // Extract video ID from YouTube URL
        const videoId = extractVideoId(youtubeUrl);
        // Fetch YouTube video from server
        const response = await fetch(`/youtube/${videoId}`);
        if (!response.ok) {
          throw new Error("Failed to fetch YouTube video");
        }
        // Set video source
        videoPlayer.src = URL.createObjectURL(await response.blob());
        // Play video
        videoPlayer.play();

        // Send the video URL to the puppet page
        sendVideoUrl(youtubeUrl);
      } catch (error) {
        console.error("Failed to stream YouTube video:", error);
      }
    });

    // Function to send video URL to puppet page
    function sendVideoUrl(url) {
      socket.emit("video url", url);
    }

    // Function to extract video ID from YouTube URL
    function extractVideoId(url) {
      const match = url.match(/[?&]v=([^&]+)/);
      return match && match[1];
    }


    videoPlayer.addEventListener("play", () =>
      socket.emit("player start", videoPlayer.play())
    );

    videoPlayer.addEventListener("pause", () =>
      socket.emit("player pause", videoPlayer.pause())
    );

    videoPlayer.addEventListener("seeking", () =>
      socket.emit("player timeupdate", videoPlayer.currentTime)
    );

    volumeControl.addEventListener("input", () =>
      socket.emit("player volumeupdate", volumeControl.value)
    );

    uploadButton.addEventListener("click", function () {
      const file = videoFileInput.files[0];
      if (file) {
          const formData = new FormData();
          formData.append("video", file);
  
          fetch("/upload", {
              method: "POST",
              body: formData,
          })
              .then((response) => {
                  if (response.ok) {
                      // Emit the uploaded video URL to the puppet page
                      socket.emit("video uploaded", videoPlayer.src);
                      if (!videoPlayer.paused) {
                          socket.emit("player start", videoPlayer.play());
                      }
                      console.log("Video uploaded successfully!");
                  } else {
                      console.error("Failed to upload video.");
                  }
              })
              .catch((error) => {
                  console.error("Error uploading video:", error);
              });
      } else {
          console.error("No file selected.");
      }
  });
  

    // Функция для обновления видеоплеера
    function updateVideoPlayer(file) {
      const url = URL.createObjectURL(file);
      videoPlayer.src = url;
      console.log(videoPlayer.src);
    }

    // Обработчик события загрузки страницы
    window.addEventListener("DOMContentLoaded", function () {
      // Вызываем функцию updateVideoPlayer при загрузке страницы, если есть выбранный файл
      if (videoFileInput.files[0]) {
        updateVideoPlayer(videoFileInput.files[0]);
      }
    });

    // Добавляем обработчик события change для input type="file"
    videoFileInput.addEventListener("change", function () {
      const file = this.files[0];
      updateVideoPlayer(file);
    });

    // Event listener for the STOP button
    stopButton.addEventListener("click", () => {
      // Stop the video playback on both pages
      socket.emit("stop");
      videoPlayer.pause();
      videoPlayer.currentTime = 0;
    });


    //VIDEO PARAMETERS:
    //Inversion:
    //Toggle inversion checkbox event listener
    toggleInversionCheckbox.addEventListener("change", () => {
      // Emit the inversion status to the server
      socket.emit("toggle inversion");
      // Apply the inversion effect locally on the master page
      if (toggleInversionCheckbox.checked) {
        videoPlayer.style.transform = "scaleX(-1) translateX(1%)";
      } else {
        videoPlayer.style.transform = "scaleX(1) translateX(0)";
      }
    });

    // Event listener for the "Optimize Color" checkbox
    optimizeColorButton.addEventListener("change", () => {
        socket.emit("optimize color");
        // Update the state of the "Optimize Color" checkbox
        optimizeColorChecked = optimizeColorButton.checked;
        // Apply filters based on the state of both checkboxes
        applyFilters();
    });

    // Event listener for the "Enhance Details" checkbox
    enhanceDetailsCheckbox.addEventListener("change", () => {
        // Emit the enhance details event to the server along with the checkbox state
        socket.emit("toggle enhance details", enhanceDetailsCheckbox.checked);
        // Update the state of the "Enhance Details" checkbox
        enhanceDetailsChecked = enhanceDetailsCheckbox.checked;
        // Apply filters based on the state of both checkboxes
        applyFilters();
    });

    // Event listener for the "optimizeBackground" checkbox
    optimizeBackgroundCheckbox.addEventListener("change", () => {
      // Emit the enhance details event to the server along with the checkbox state
      socket.emit("toggle background details", optimizeBackgroundCheckbox.checked);
      // Update the state of the "Enhance Details" checkbox
      backgroundOptimizeChecked = optimizeBackgroundCheckbox.checked;
      // Apply filters based on the state of both checkboxes
      applyFilters();
    });

    // Function to apply filters based on the state of filter checkboxes
    function applyFilters() {
      let filters = "";

      if (optimizeColorChecked) {
          // Apply filters for optimizing color
          filters += " contrast(130%) saturate(130%)";
      }

      if (enhanceDetailsChecked) {
          // Apply filters for enhancing details
          // Adjust as needed based on your specific enhancements
          filters += " brightness(110%) blur(1px)";
      }

      if (backgroundOptimizeChecked) {
        // Apply filters for enhancing details
        // Adjust as needed based on your specific enhancements
        analyzeVideoFrames(videoPlayer);
      }
      // Set the combined filters to the video player
      videoPlayer.style.filter = filters || "none";
    }

    // Function to analyze video frames and adjust opacity for black and white colors
    async function analyzeVideoFrames(video) {
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      const width = video.videoWidth;
      const height = video.videoHeight;

      // Set canvas dimensions to match video
      canvas.width = width;
      canvas.height = height;

      // Interval for processing video frames
      const frameInterval = 1000 / video.playbackRate;

      // Function to process a single video frame
      async function processFrame() {
        // Draw current frame onto canvas
        context.drawImage(video, 0, 0, width, height);

        // Get pixel data
        let imageData;
        try {
          imageData = await createImageBitmap(canvas);
        } catch (error) {
          console.error("Error creating image bitmap:", error);
          return;
        }

        // Ensure imageData is not null or undefined
        if (!imageData) {
            console.error("Failed to retrieve image data.");
            return;
        }

        // Loop through pixels and adjust opacity for black and white colors
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                // Check if pixel color is black or white
                const { r, g, b, a } = getPixel(imageData, x, y);
                if (isBlackOrWhite(r, g, b)) {
                    // Set opacity to 0% for black and white pixels
                    setPixel(imageData, x, y, { r, g, b, a: 0 });
                }
            }
        }

        // Update canvas with modified pixel data
        context.putImageData(imageData, 0, 0);

        // Draw modified canvas back to video element
        video.srcObject = canvas.captureStream();

        // Check if video has ended
        if (!video.ended) {
            // Schedule processing of the next frame
            setTimeout(processFrame, frameInterval);
        }
      }

      // Start processing the first frame
      processFrame();
    }


    // Function to extract pixel color information from image data
    function getPixel(imageData, x, y) {
      const index = (y * imageData.width + x) * 4;
      return {
          r: imageData.data[index],
          g: imageData.data[index + 1],
          b: imageData.data[index + 2],
          a: imageData.data[index + 3]
      };
    }

    // Function to set pixel color information in image data
    function setPixel(imageData, x, y, { r, g, b, a }) {
      const index = (y * imageData.width + x) * 4;
      imageData.data[index] = r;
      imageData.data[index + 1] = g;
      imageData.data[index + 2] = b;
      imageData.data[index + 3] = a;
    }

    // Function to check if a color is black or white
    function isBlackOrWhite(r, g, b) {
      // Define threshold for black and white colors
      const threshold = 30;

      // Calculate grayscale value
      const gray = (r + g + b) / 3;

      // Check if grayscale value is close to 0 (black) or 255 (white)
      return (gray < threshold || gray > 255 - threshold);
    }

    // Initial call to apply filters based on the initial state of checkboxes
    applyFilters();
  </script>
</html>
